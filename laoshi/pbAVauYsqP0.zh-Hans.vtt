WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.180 --> 00:00:02.080
各位同学大家好 我是李永乐老师

00:00:02.200 --> 00:00:05.200
在上一回咱们讲了比特币和区块链的基本原理

00:00:05.200 --> 00:00:07.480
知道了比特币是一种电子记账系统

00:00:07.825 --> 00:00:10.960
但是它的所有记录都是公开而且匿名的

00:00:11.000 --> 00:00:12.640
这样比特币就面临几个问题

00:00:12.640 --> 00:00:17.293
它如何去解决伪造记录 篡改记录或者是双重支付的问题

00:00:17.389 --> 00:00:19.320
今天我们就来研究一下这几个问题

00:00:19.840 --> 00:00:25.280
我们首先来说一下如何保证比特币的交易记录是真实的

00:00:25.280 --> 00:00:29.187
也就是如何进行身份认证

00:00:29.452 --> 00:00:34.080
我们必须保证每一条记录都是由比特币持有者所发出的

00:00:34.120 --> 00:00:35.619
而不是由其他人伪造的

00:00:35.763 --> 00:00:40.640
那么传统的记录认证方式有哪些

00:00:40.640 --> 00:00:43.493
传统的方式比如说可以刷脸 对吧

00:00:43.493 --> 00:00:44.440
人脸识别

00:00:44.760 --> 00:00:47.640
我们去银行办业务 银行要求我们必须本人去

00:00:47.640 --> 00:00:49.320
为什么 因为他要刷脸 是吧

00:00:49.320 --> 00:00:53.480
第二个就是签名 我们可以在某个文件上签字

00:00:53.520 --> 00:00:55.331
表示我们认可这份文件了

00:00:55.443 --> 00:00:58.776
或者再狠一点 我们搞指纹

00:00:59.721 --> 00:01:01.160
每个人的指纹不一样

00:01:01.160 --> 00:01:03.662
你按了手印就表示这个是是你认可的 对吧

00:01:03.662 --> 00:01:07.130
但是这些方式在电子支付系统上都不能实现 为什么呢

00:01:07.130 --> 00:01:09.292
因为无论是人脸签名还是指纹

00:01:09.292 --> 00:01:12.040
我利用计算机系统我都可以进行拷贝 对吧

00:01:12.040 --> 00:01:15.960
我可以拷贝下来你的签名 然后添加到我伪造的记录上

00:01:15.960 --> 00:01:16.880
这不就行了吗

00:01:16.880 --> 00:01:20.234
所以我们必须对这种传统的身份认证方式进行更改

00:01:20.314 --> 00:01:23.294
怎么改呢 就叫电子签名

00:01:24.022 --> 00:01:26.690
电子签名系统咱们在之前已经讲过了

00:01:26.690 --> 00:01:30.927
就是我们讲生日碰撞和哈希函数的时候提到过这个问题

00:01:31.015 --> 00:01:34.043
我们现在具体的针对比特币 再来讲一下这个事儿

00:01:34.123 --> 00:01:38.200
首先一个比特币的用户他在注册的时候

00:01:38.368 --> 00:01:40.600
系统会生成一个随机数

00:01:42.069 --> 00:01:47.091
然后通过这个随机数它会产生一个叫做私钥的字符串

00:01:47.555 --> 00:01:53.210
私钥字符串 这个私钥又可以产生一个叫做公钥的字符串

00:01:53.419 --> 00:01:55.120
私钥和公钥是对应的

00:01:55.120 --> 00:01:57.816
同时又可以产生一个地址

00:01:59.722 --> 00:02:01.829
那么这些东西它的重要性是不一样的

00:02:01.829 --> 00:02:06.298
首先这个私钥你必须保存好了 他是你私有的保密的

00:02:06.499 --> 00:02:10.160
如果你的私钥丢了 那你的所有比特币就都不见了

00:02:10.160 --> 00:02:12.520
那私钥你必须存好也不能让别人知道

00:02:12.520 --> 00:02:15.240
所以有些人把私钥放在一个不联网的电脑里面

00:02:15.240 --> 00:02:17.240
也有一些人把它背下来记到脑子里

00:02:17.240 --> 00:02:21.309
但是这私钥不能丢 而公钥和地址都是公开的

00:02:21.949 --> 00:02:23.792
如果你想让别人给你钱的话

00:02:23.792 --> 00:02:25.234
你就把你的地址告诉他就可以了

00:02:25.234 --> 00:02:26.635
如果你想给别人钱的话

00:02:26.635 --> 00:02:28.822
你要把你的公钥和地址一起发送过去

00:02:28.902 --> 00:02:30.824
但是这两个都是公开的 没有关系

00:02:30.960 --> 00:02:33.840
而且通过公钥也反算不出来私钥

00:02:33.840 --> 00:02:35.880
咱们上次说过你像SHA256算法

00:02:35.880 --> 00:02:37.600
你只能正着算 反着算不出来

00:02:37.600 --> 00:02:39.600
同样的私钥到公钥可以算

00:02:39.600 --> 00:02:41.960
但是反过来公钥到私钥是算不出来的

00:02:41.960 --> 00:02:43.560
这也是一种加密手段

00:02:43.560 --> 00:02:45.680
好了 那么私钥和公钥有什么作用呢

00:02:45.680 --> 00:02:48.382
私钥可以对一串字符进行加密

00:02:48.830 --> 00:02:50.520
可以对一串字符进行加密

00:02:50.520 --> 00:02:55.943
而公钥可以把这个私钥加密之后的数据进行解密

00:02:58.715 --> 00:03:01.061
那么加密和解密它这个钥匙不一样

00:03:01.061 --> 00:03:05.339
这种加密方法我们称之为什么 称之为非对称加密

00:03:05.459 --> 00:03:08.879
比如最典型的非对称加密就是RSA加密 对吧

00:03:09.400 --> 00:03:11.720
这个比特币也是使用了非对称加密

00:03:11.720 --> 00:03:14.760
它加密的时候使用私钥 而解密的时候使用公钥

00:03:14.760 --> 00:03:18.731
只有你能够加密 而任何人都可以解密你加密之后的信息

00:03:18.819 --> 00:03:21.246
好了 现在我们就想问 假如有一个人 A

00:03:21.246 --> 00:03:23.417
他想付给B十个比特币 他该怎么办

00:03:23.880 --> 00:03:27.640
那么A他要做这么一件事 首先他写一条记录

00:03:27.640 --> 00:03:32.172
就是A付给B十个比特币写这么一条记录

00:03:32.252 --> 00:03:37.160
写完了这条记录之后 他把这条记录进行数字摘要

00:03:37.160 --> 00:03:38.507
也就是哈希运算

00:03:38.996 --> 00:03:43.960
他进行哈希运算算出一个摘要来 这个摘要就出来了

00:03:43.960 --> 00:03:47.190
其实就是通过这个SHA256算法算出来的摘要

00:03:47.334 --> 00:03:49.256
好 这个摘要算完了之后

00:03:49.256 --> 00:03:54.046
他再通过自己的这个私钥进行干嘛 进行加密

00:03:55.024 --> 00:03:58.332
加密完了之后它就会产生一个密码 对吧

00:03:59.725 --> 00:04:03.320
好 这是A要干的事 然后他进行广播

00:04:03.320 --> 00:04:06.365
他对全网进行广播 他广播什么

00:04:06.478 --> 00:04:12.680
他首先把A给B十个比特币这件事儿 他要进行广播

00:04:13.094 --> 00:04:15.825
告诉别人说我给了B十个比特币了 是吧

00:04:15.825 --> 00:04:20.080
然后他同时还要把自己的公钥广播出去

00:04:20.080 --> 00:04:22.337
他要告诉别人我的公钥是什么

00:04:23.066 --> 00:04:28.400
同时他还要把这个密码 就是刚才他经过加密之后的这个密码

00:04:28.400 --> 00:04:29.682
也广播出去

00:04:31.092 --> 00:04:33.880
然后别人拿到了他的广播之后就去琢磨

00:04:33.880 --> 00:04:36.050
说这一条信息说A给B十个比特币

00:04:36.050 --> 00:04:38.040
那对不对 是不是真的是A给的

00:04:38.040 --> 00:04:40.160
别人怎么去验证 这么验证

00:04:40.160 --> 00:04:45.240
首先其他接收到这条消息的人会对这条信息做哈希运算

00:04:45.902 --> 00:04:49.498
得出一个摘要来 得出这个摘要来

00:04:51.269 --> 00:04:54.640
这个摘要其实和A自己算出来摘要是完全一样的 对吧

00:04:54.753 --> 00:04:57.360
同时利用公钥和密码进行解密

00:04:57.360 --> 00:05:00.280
我们知道用公钥就可以解密一条信息 对吧

00:05:00.280 --> 00:05:02.000
利用公钥和密码进行解密

00:05:02.394 --> 00:05:04.116
他解密出一个…

00:05:05.598 --> 00:05:07.320
密码对应的是什么 是摘要吧

00:05:07.320 --> 00:05:09.640
所以他也解密出一个摘要来

00:05:10.452 --> 00:05:13.480
我们不妨称这个是摘要1 这个是摘要2

00:05:13.480 --> 00:05:17.533
然后他会把这两个摘要进行对比 进行对比

00:05:17.621 --> 00:05:19.800
如果摘要1和摘要2相等

00:05:19.800 --> 00:05:22.480
就说明你这个密码是符合要求的

00:05:22.480 --> 00:05:25.640
这个密码符合要求 因为你有你唯一的私钥 对吧

00:05:25.640 --> 00:05:26.928
所以你可以进行加密

00:05:26.928 --> 00:05:31.125
我就认为这个确实是A的广播

00:05:31.125 --> 00:05:33.897
但如果你发现这个摘要1和摘要2是不一样的

00:05:33.897 --> 00:05:36.120
那就说明什么 这就说明这条消息是伪造的

00:05:36.120 --> 00:05:39.360
于是所有的用户都会拒绝这条消息

00:05:39.360 --> 00:05:40.520
这样一来就保证了

00:05:40.520 --> 00:05:44.101
所有A发给B的消息都是由A签发的 对吧

00:05:44.101 --> 00:05:46.640
这种方式我们就称之为电子签名

00:05:46.640 --> 00:05:50.080
是利用了这个哈希运算的这种办法来进行电子签名

00:05:50.080 --> 00:05:53.080
其实我们的银行卡很多的时候也是用这种方法进行签名的

00:05:53.120 --> 00:05:53.960
原理差不多

00:05:53.960 --> 00:05:55.179
好 那么这是第一个问题

00:05:55.179 --> 00:05:57.320
就是如何证明A发给B十个比特币

00:05:57.320 --> 00:06:00.160
这条消息是A发出而不是伪造的 就是防伪

00:06:00.160 --> 00:06:03.520
但还有另外一个问题 就是如果A要给B十个比特币

00:06:03.520 --> 00:06:05.800
A根本自己就没有十个比特币 那该怎么办

00:06:05.800 --> 00:06:07.960
或者说A本来就只有十个比特币

00:06:07.960 --> 00:06:11.040
但他同时发了两条消息 一条是给B十个比特币

00:06:11.040 --> 00:06:12.440
一条给C十个比特币

00:06:12.440 --> 00:06:15.440
那这个时候别人又如何去鉴别 这就是第二个问题

00:06:15.440 --> 00:06:18.200
我们如何对付双重支付

00:06:18.648 --> 00:06:22.572
双重支付的问题 如何对付双重支付的问题

00:06:23.502 --> 00:06:24.800
好 我们来研究一下这个事

00:06:24.800 --> 00:06:25.720
要解决这个问题

00:06:25.720 --> 00:06:31.944
我们首先先来说一下如何进行余额的检查

00:06:32.923 --> 00:06:34.723
如何进行余额的检查

00:06:34.843 --> 00:06:37.615
什么叫余额检查 就是说你本来只有十个比特币

00:06:37.615 --> 00:06:40.018
你非要付给别人二十个 那我就要拒绝 对吧

00:06:40.018 --> 00:06:41.444
我怎么去拒绝这件事

00:06:41.600 --> 00:06:45.360
我们知道区块链是把很多的交易信息

00:06:45.360 --> 00:06:49.165
一个一块打包再把它穿一个串链起来的

00:06:49.317 --> 00:06:52.930
而且每一个人在使用这个区块链比特币的时候

00:06:52.930 --> 00:06:54.480
他都会下载所有的信息

00:06:54.480 --> 00:06:57.543
就从第一个创世纪的这个块开始

00:06:57.543 --> 00:06:59.490
一直到后面所有的信息 他都知道

00:06:59.610 --> 00:07:03.560
所以如果有一天A说了我要付给B十个比特币

00:07:03.560 --> 00:07:06.090
并且把这件事给广播出去

00:07:06.178 --> 00:07:08.840
那么别人接触到这个信息之后就去检查

00:07:08.840 --> 00:07:12.160
怎么检查 就会去找说A你的比特币从哪来的

00:07:12.200 --> 00:07:18.400
比如在这个块里面A已经通过挖矿他获得了五十个比特币

00:07:18.400 --> 00:07:24.240
然后在这个块里面A已经支付了二十个比特币 对吧

00:07:24.280 --> 00:07:27.920
这样一来人们一算获得五十 支付了二十 你现在还剩三十

00:07:27.920 --> 00:07:30.000
所以你付给B二十 这个可以

00:07:30.000 --> 00:07:33.160
于是这条消息就会被网络所接受

00:07:33.160 --> 00:07:36.160
但是如果A说了说我要付给B六十个比特币

00:07:36.527 --> 00:07:39.040
那么别人就算 一算发现你只剩三十了

00:07:39.040 --> 00:07:42.520
你付给B六十个比特币 那么别人会拒绝这条消息

00:07:42.647 --> 00:07:45.040
所以它不会被确认 你发出去也没有用

00:07:45.080 --> 00:07:47.640
因为别人不能被确认 什么时候被确认

00:07:47.640 --> 00:07:50.160
直到你这条消息被别人接受了

00:07:50.160 --> 00:07:53.171
并且打包到一个新的块里边了 对吧

00:07:53.171 --> 00:07:55.070
这个新的块里边含有这个消息

00:07:55.070 --> 00:07:57.480
就是A付给B十个比特币了

00:07:57.520 --> 00:07:59.347
那么就算你信息被确认了

00:07:59.347 --> 00:08:01.520
所以这样就可以解决你的余额的问题

00:08:01.520 --> 00:08:04.628
方法就是通过追溯

00:08:04.890 --> 00:08:06.400
好 这是第一个问题

00:08:06.400 --> 00:08:10.993
那么第二个问题就是如果A进行了双重支付怎么办

00:08:11.418 --> 00:08:12.800
什么叫双重支付

00:08:12.800 --> 00:08:15.240
比如生活中有这样的一种人 他卖房子

00:08:15.240 --> 00:08:18.040
结果卖房子的时候他同时跟两个买家签约

00:08:18.040 --> 00:08:21.120
他把这一个房子卖了两次 这就叫双重支付

00:08:21.120 --> 00:08:23.449
同样在比特币上也存在这样一个问题

00:08:23.449 --> 00:08:27.293
假如有一个人 A他本来就有十个比特币 对吧

00:08:28.719 --> 00:08:31.731
但是他几乎同时的发了两条消息

00:08:31.859 --> 00:08:36.184
第一条消息叫A付了十个比特币给B

00:08:37.153 --> 00:08:38.659
付了这么个消息

00:08:38.779 --> 00:08:41.783
第二条消息叫A付了十个比特币给C

00:08:41.903 --> 00:08:44.480
他几乎同时发出这两条消息了

00:08:44.480 --> 00:08:46.068
那么这回会有什么结果

00:08:46.156 --> 00:08:49.760
每一个这个网络上的接收者他接收到A的消息之后

00:08:49.760 --> 00:08:52.000
都会去算 说A的余额还够不够

00:08:52.080 --> 00:08:54.720
结果如果有人接触到第一条消息的话

00:08:54.720 --> 00:08:56.600
他再接受第二条消息 他就会拒绝

00:08:56.600 --> 00:08:58.320
因为网络上的每一个用户

00:08:58.360 --> 00:09:01.880
接收到这个A的消息之后都会去追溯 看一看A的余额够不够

00:09:01.920 --> 00:09:05.764
所以有些人可能会先接收到上面这条消息

00:09:05.973 --> 00:09:07.920
他接收到上面一条消息的时候

00:09:07.960 --> 00:09:09.720
他就会自然而然拒绝后面这条消息

00:09:09.720 --> 00:09:11.040
因为他的余额已经不够了

00:09:11.040 --> 00:09:14.039
当然也有一些人可能先接触到底下这条消息

00:09:14.119 --> 00:09:16.674
这样一来他自然会拒绝上面这条消息 对吧

00:09:16.674 --> 00:09:18.720
此时接收到了也没有用

00:09:18.760 --> 00:09:22.273
因为他们会把这个消息打包在自己这个块里边

00:09:22.353 --> 00:09:24.019
此时还没有确认呢

00:09:25.276 --> 00:09:27.960
那什么时候确认呢 直到有一个幸运儿

00:09:27.960 --> 00:09:30.760
找到了那道数学题的解 然后打了一个新的块

00:09:30.760 --> 00:09:34.800
比如说这个人吧 这个人他突然之间找到了一个数学题的解

00:09:34.840 --> 00:09:37.160
找到这个数学题解就相当于挖到了一个矿

00:09:37.160 --> 00:09:40.040
于是他就到了一个新的块 对吧

00:09:40.040 --> 00:09:43.987
造了一个新的区块 这个区块里边就包含这条消息

00:09:43.987 --> 00:09:47.015
A付了十个比特币给B 这个消息

00:09:47.151 --> 00:09:51.565
然后他又把这个块给链接到刚才的这个上面了

00:09:51.565 --> 00:09:55.000
链接到上面去了 这样一来这条消息就会被确认

00:09:55.000 --> 00:09:56.720
而这条消息被确认之后

00:09:56.720 --> 00:10:01.320
刚才打包了底下这条记录的这些人一看上面就有个新块

00:10:01.320 --> 00:10:04.292
于是怎么样 所有人都会放弃自己这个块

00:10:04.292 --> 00:10:06.240
所有人都会放弃自己这个块

00:10:06.280 --> 00:10:08.842
转而所有人都会站队 站到顶上去

00:10:08.938 --> 00:10:10.800
也就是说上面一条消息被确认

00:10:10.800 --> 00:10:12.600
而底下这条消息又被抛弃

00:10:12.600 --> 00:10:16.640
同样道理 如果很幸运底下这个人算出这道数学题了

00:10:16.640 --> 00:10:19.720
那么这条消息就会被确认 而上面这条消息就会被放弃

00:10:19.720 --> 00:10:22.200
所以当我们接收到别人给我们付款的时候

00:10:22.200 --> 00:10:25.014
我们不能当时就认为钱已经到账了 我们必须等着

00:10:25.014 --> 00:10:27.921
等到什么时候 等到这个块已经形成了

00:10:27.921 --> 00:10:30.949
我们这条消息已经被记录到这条主链上了

00:10:30.949 --> 00:10:33.360
我们才能认为这个钱真正打给我们了

00:10:33.360 --> 00:10:36.163
这就是我们如何去防止双重支付的问题

00:10:36.163 --> 00:10:37.821
那么比特币还有一个问题

00:10:37.821 --> 00:10:43.076
就是它如何防止篡改

00:10:46.688 --> 00:10:48.720
比如说有一个想篡改记录的人

00:10:48.720 --> 00:10:50.520
他不可能伪造别人的签名

00:10:50.520 --> 00:10:53.080
因为签名这事不可伪造的 对吧 电子签名

00:10:53.080 --> 00:10:54.960
但是他可以删掉某一条记录

00:10:55.000 --> 00:10:57.720
比如说他本来付给了别人十个比特币

00:10:57.720 --> 00:10:59.520
现在他想把这个记录删掉 对吧

00:10:59.520 --> 00:11:01.240
伪造一下篡改一下这个纪录

00:11:01.280 --> 00:11:03.000
那我怎么防止这件事

00:11:03.000 --> 00:11:08.275
首先我们要说比特币有个原则叫最长链原则

00:11:08.555 --> 00:11:10.589
最长链原则

00:11:11.374 --> 00:11:13.281
什么叫最长链原则

00:11:13.361 --> 00:11:16.789
就是说这是一个区块链

00:11:18.111 --> 00:11:20.265
比如说目前已经算到这个地方了

00:11:20.265 --> 00:11:24.080
那么下面有很多的矿工在那拼命的找方法去打包一个新块

00:11:24.080 --> 00:11:26.769
结果很有意思的是几乎同时

00:11:26.769 --> 00:11:30.077
有两个矿工分别找到了一个新的块

00:11:30.366 --> 00:11:31.880
分别找到了一个新的块

00:11:31.880 --> 00:11:34.200
然后把新的信息向周围人广播

00:11:34.200 --> 00:11:36.445
广播了之后有些人一看

00:11:37.286 --> 00:11:39.633
上面这个已经有人找到新块了 是吧

00:11:39.633 --> 00:11:41.920
底下人一看也有一个人找到块了

00:11:41.960 --> 00:11:43.478
而且找到新块是底下这个

00:11:43.478 --> 00:11:46.160
好 现在这两拨人每一个人

00:11:46.160 --> 00:11:48.520
都会以自己接收到的第一个新块为准

00:11:48.560 --> 00:11:52.360
他接收到这个块 当然他也知道好像还有个分支 那怎么办

00:11:52.360 --> 00:11:56.600
他们先不管 先按照自己的接受到的块继续往下算

00:11:56.640 --> 00:11:58.945
直到某一个时候比如说有个幸运儿

00:11:58.945 --> 00:12:02.040
比如这个人他算出来了下一个块

00:12:02.040 --> 00:12:05.440
那于是就在自己战队的排列上又加了一个块

00:12:05.440 --> 00:12:09.200
大家看此时这条链就比这条链要长了

00:12:09.240 --> 00:12:11.160
当他把这条消息广播出去之后

00:12:11.200 --> 00:12:13.362
全网都会知道这条链更长一些

00:12:13.450 --> 00:12:15.200
这样一来这些人会怎么样

00:12:15.200 --> 00:12:17.560
这些人会重新站队跑到上面去

00:12:17.560 --> 00:12:20.523
然后大家再继续往下去算链 是吧

00:12:20.523 --> 00:12:24.752
继续往下算 那刚才挖矿这个人他就失败了

00:12:24.752 --> 00:12:26.755
这个矿本来被挖出来的结果又被废弃了

00:12:27.011 --> 00:12:28.717
那有人说我就不上去

00:12:28.717 --> 00:12:31.144
我就在我底下这条链往下走 行不行

00:12:31.144 --> 00:12:35.558
那也可以 但问题是全网的基本原则都是找最长链

00:12:35.640 --> 00:12:39.560
如果你认为你自己一个人可以对抗其余所有的人

00:12:39.560 --> 00:12:44.256
你可以最后造的这个链比刚才那个链还要长很多很多

00:12:44.256 --> 00:12:45.842
那行 你就在底下继续挖

00:12:45.842 --> 00:12:49.480
但是大家都认为最长链是最有希望成为公认原则的

00:12:49.480 --> 00:12:51.249
所以大家都会往最长的链去跑

00:12:51.593 --> 00:12:53.460
好了 有了这个最长链原则之后

00:12:53.460 --> 00:12:57.777
我们就可以说一下怎么样去防止篡改了

00:12:58.297 --> 00:12:59.827
怎么样去防止篡改

00:12:59.827 --> 00:13:02.238
我们看一下刚才我们说过

00:13:02.967 --> 00:13:06.732
有一个人他希望抹掉自己的一条记录

00:13:06.828 --> 00:13:11.442
什么记录 就这个人A他本来是支付给了B十个比特币的

00:13:11.530 --> 00:13:13.228
但是现在他不想要记录了

00:13:13.228 --> 00:13:15.240
他要想把它给抹掉 那怎么办

00:13:15.280 --> 00:13:16.936
他可以通过这样的一个方法

00:13:16.936 --> 00:13:19.219
就是后面本来已经有一个链了 对吧

00:13:19.219 --> 00:13:22.215
已经有一个链 现在他在这重新计算

00:13:22.343 --> 00:13:25.600
重新打包重新计算 算出一道数学题来

00:13:25.600 --> 00:13:27.480
大家注意这个工作量是很大的

00:13:27.520 --> 00:13:29.480
全世界一起算每十分钟出一个

00:13:29.520 --> 00:13:32.560
但是你作为一个个人你想改掉这个东西

00:13:32.600 --> 00:13:34.200
那你就要自己算出来 对吧

00:13:34.200 --> 00:13:37.009
算出来之后你重新打包 于是造出一个支链来

00:13:37.009 --> 00:13:39.524
这个支链里是不含A给B的信息的

00:13:39.524 --> 00:13:42.424
好 你伪造 伪造了之后别人不承认 为什么

00:13:42.424 --> 00:13:43.753
因为这条链不够长 对吧

00:13:43.753 --> 00:13:48.695
于是怎么办 于是你在这个上面算继续往下算...

00:13:48.847 --> 00:13:52.700
什么时候你算的比别人全世界算的还要长了

00:13:52.700 --> 00:13:55.616
那么全世界的人都会跟到你 于是你伪造就成功了

00:13:55.616 --> 00:13:58.880
也就是说理论上来讲你是可以进行改动的

00:13:58.880 --> 00:14:01.000
但问题是改动了之后别人不承认

00:14:01.040 --> 00:14:04.619
除非你的计算能力超过了世界上其余所有的人 对吧

00:14:04.699 --> 00:14:07.200
那有人说那万一就有这样的一个坏人

00:14:07.200 --> 00:14:08.960
他控制了全世界50%以上的电脑

00:14:09.000 --> 00:14:11.539
然后就为了改掉一个区块链的记录

00:14:11.539 --> 00:14:14.559
大家要注意如果一个人他有很多钱的话

00:14:14.559 --> 00:14:16.706
他就不会去甘当一个小偷

00:14:16.794 --> 00:14:18.880
同样道理如果有一个人

00:14:18.920 --> 00:14:21.840
他能够控制全世界50%以上的电脑的话

00:14:21.840 --> 00:14:25.268
那么他不会去通过这种办法就为了抹掉自己的一条记录

00:14:25.268 --> 00:14:28.480
他为什么不在这条真正链上努力的挖矿

00:14:28.520 --> 00:14:29.840
让自己有更多的钱

00:14:29.840 --> 00:14:31.520
所以从这个角度上来讲

00:14:31.560 --> 00:14:34.000
比特币就是通过这样的方法来防止篡改的

00:14:34.040 --> 00:14:36.920
就是你一旦想篡改你是跟全世界的人进行对抗的

00:14:36.960 --> 00:14:41.120
你需要链接很长的链 然后还能战胜全世界其他所有的人

00:14:41.120 --> 00:14:44.019
所以这件事其实可能性是非常非常低的

00:14:44.019 --> 00:14:47.440
而且随着后续的链的增加 你改动的难度就越来越大

00:14:47.440 --> 00:14:49.640
所以一般大额的交易都要多等几个块

00:14:49.640 --> 00:14:50.920
比如说等6个块之后

00:14:50.920 --> 00:14:53.511
我们就认为基本上没有可能再去进行篡改了

00:14:53.511 --> 00:14:55.000
我们就确认这个消息了

00:14:55.000 --> 00:14:58.701
比特币作为一种技术手段是非常新颖而且漂亮的

00:14:58.701 --> 00:15:00.744
比特币也没有一个中心发行机构

00:15:00.744 --> 00:15:01.985
不用担心主权危机

00:15:01.985 --> 00:15:04.572
比特币总量固定不会存在滥发的风险

00:15:04.572 --> 00:15:06.160
比特币天生具有防伪属性

00:15:06.200 --> 00:15:09.386
而且可以追溯 比特币交易的时候手续费非常低

00:15:09.386 --> 00:15:10.480
由于有这么多的优点

00:15:10.480 --> 00:15:13.407
有人甚至提名中本聪应该获得诺贝尔经济学奖

00:15:13.407 --> 00:15:15.760
但是又因为比特币是一种匿名的货币

00:15:15.800 --> 00:15:18.640
它在进行交易的时候只需要一个公钥和一个地址

00:15:18.640 --> 00:15:20.872
你又不知道这公钥和地址到底是谁

00:15:20.872 --> 00:15:23.571
所以就给很多犯罪分子提供了可乘之机

00:15:23.571 --> 00:15:27.200
比如有人利用比特币进行敲诈 进行贩毒 进行洗钱

00:15:27.240 --> 00:15:28.225
等等这样的活动

00:15:28.225 --> 00:15:29.800
也受到了一些政府部门的打击

00:15:29.800 --> 00:15:32.454
还有一些人把比特币当作一种投机手段

00:15:32.454 --> 00:15:35.266
比特币暴涨暴跌造成了许多人一夜暴富

00:15:35.266 --> 00:15:36.828
也有许多人倾家荡产

00:15:36.932 --> 00:15:39.719
我想大家应该把比特币看作是一种技术手段

00:15:39.719 --> 00:15:43.040
如果要购买比特币 也应该从投资而不是投机的角度

00:15:43.040 --> 00:15:47.040
因为从长期来看 任何一种投机行为都会使你输得倾家荡产

00:15:47.040 --> 00:15:49.563
而只有投资才能使你稳定的获益

00:15:49.716 --> 00:15:50.933
大家如果喜欢我的视频

00:15:50.940 --> 00:15:53.700
可以在西瓜视频和YouTube帐号李永乐老师里关注我

