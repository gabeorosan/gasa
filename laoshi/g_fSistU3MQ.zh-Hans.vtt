WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.360 --> 00:00:02.920
各位同学大家好 我是李永乐老师

00:00:02.920 --> 00:00:05.040
经常有小朋友问我比特币到底是什么

00:00:05.090 --> 00:00:08.580
我们准备通过两期节目给大家介绍一下比特币的基本原理

00:00:08.640 --> 00:00:12.299
那今天我们首先来介绍一下挖矿到底是怎么回事

00:00:12.580 --> 00:00:14.147
比特币是什么呢

00:00:14.460 --> 00:00:19.437
比特币实际上是一种电子货币或者叫数字货币

00:00:19.720 --> 00:00:21.930
它是基于密码学的一种货币

00:00:22.090 --> 00:00:25.840
这种货币跟我们以前用银行卡里面那个货币它不太一样

00:00:26.240 --> 00:00:27.950
它的出现是一种传奇

00:00:27.990 --> 00:00:30.670
在2008年的时候金融危机

00:00:30.710 --> 00:00:34.830
2008年11月1日的时候有一个网络极客

00:00:34.890 --> 00:00:37.240
他化名叫中本聪

00:00:37.640 --> 00:00:40.690
这个中本聪我们到目前为止也不知道他到底是谁

00:00:41.130 --> 00:00:43.124
他在网络上发表的一篇文章

00:00:43.210 --> 00:00:45.880
这篇文章我们现在管它叫《白皮书》

00:00:48.130 --> 00:00:51.080
全名叫比特币一种点对点的电子现金系统

00:00:51.180 --> 00:00:54.500
他在这个白皮书里面提出了这样一种构想

00:00:54.550 --> 00:01:01.360
就是说我们可以设计一种去中心化的电子记账系统

00:01:02.450 --> 00:01:05.160
去中心化的电子记账系统

00:01:05.430 --> 00:01:08.920
我们在进行交易的时候最重要的一件事就是记账

00:01:10.350 --> 00:01:12.520
比如说我付给你多少多少钱

00:01:12.530 --> 00:01:15.160
我要检查我自己的银行卡里还有没有这么多钱

00:01:15.450 --> 00:01:17.640
我付给你之后还剩多少钱这就叫记账

00:01:18.090 --> 00:01:20.240
那现在的记账是谁来记呢 是银行记

00:01:20.250 --> 00:01:25.840
我们不管是用信用卡还是用这个支付宝或者微信都是银行来记账

00:01:25.880 --> 00:01:29.080
我们信任银行 因为银行的背后是国家的信用 对不对

00:01:29.330 --> 00:01:31.420
那么这个中本聪就说

00:01:31.530 --> 00:01:34.030
其实我们并不需要一种中心化的这个记账系统

00:01:34.070 --> 00:01:35.300
我们可以去中心化

00:01:35.310 --> 00:01:38.470
每一个人的账本都是让别人去看 都是公开的

00:01:38.750 --> 00:01:40.890
这就叫去中心化电子记账系统

00:01:40.940 --> 00:01:43.910
举个例子来说 比如说有这么几个小朋友

00:01:43.960 --> 00:01:46.775
这几个小朋友分别叫A B C D

00:01:47.821 --> 00:01:50.920
他们进行交易买东西卖东西之类的

00:01:50.970 --> 00:01:53.150
那所以相互之间就要进行支付

00:01:53.640 --> 00:01:59.880
支付的时候比如说有一次A先支付了10个比特币给B

00:02:00.170 --> 00:02:03.320
这件事情要记账 记账了之后你不能自己留着

00:02:03.330 --> 00:02:04.590
因为你自己留着别人不信

00:02:05.020 --> 00:02:08.240
所以你要把这个账单要广播出去要告诉所有人

00:02:08.250 --> 00:02:11.340
所以说A把这账单告诉B 告诉C 又告诉D

00:02:11.510 --> 00:02:12.970
广播到网络上所有人

00:02:13.060 --> 00:02:14.770
过了一会B也要进行支付

00:02:14.810 --> 00:02:18.430
比如说B支付了5个比特币给C

00:02:18.470 --> 00:02:22.809
同时B把这个账单告诉D 告诉A 再告诉C

00:02:23.140 --> 00:02:27.910
然后这个C又支付 比如支付了2个比特币给D

00:02:28.420 --> 00:02:33.420
同时C也要把这个账单告诉其余的所有的人 这样

00:02:33.610 --> 00:02:37.680
那么这个账单我们会把它进行打包 打包成一个块

00:02:37.850 --> 00:02:40.199
这个块我们就叫它区块

00:02:41.400 --> 00:02:43.910
这一个区块里面它大小大概是一兆

00:02:44.140 --> 00:02:47.250
我们可以存4000条左右的交易记录

00:02:47.260 --> 00:02:48.810
有时候多一点 有时候少一点

00:02:48.820 --> 00:02:50.310
是取决于每一条记录的大小

00:02:50.600 --> 00:02:52.290
好了 这个块打包完了之后

00:02:52.300 --> 00:02:56.630
我们再把这个块链接到以前的交易记录上形成了一条链

00:02:56.780 --> 00:02:58.430
就把这个块接到以前的块上

00:02:58.470 --> 00:03:01.890
然后过一会再把新的块接到它后面 就叫区块链

00:03:01.930 --> 00:03:03.076
就这么回事 对吧

00:03:03.110 --> 00:03:06.070
那好 我们有了这么一个系统之后就要解决几个问题

00:03:06.080 --> 00:03:11.650
什么问题呢 比如说账单以谁为准 这就是一个问题

00:03:11.980 --> 00:03:13.410
以谁为准

00:03:13.970 --> 00:03:15.970
因为每个人的账单可能是不一样的

00:03:16.010 --> 00:03:20.215
比如说A他可能会先记录A把10个比特币给B这件事

00:03:20.215 --> 00:03:22.690
后记录B把5个比特币给C这件事

00:03:22.860 --> 00:03:26.030
但是因为网络的延迟效应 D这边可能不是这样

00:03:26.040 --> 00:03:29.170
D的顺序可能是先记录的B付5个比特币给C

00:03:29.210 --> 00:03:31.320
然后A又付了10个比特币给B

00:03:31.620 --> 00:03:33.050
每个人的账单可能不太一样

00:03:33.060 --> 00:03:34.260
你到底是以谁为准

00:03:34.330 --> 00:03:37.050
第二个就是我们为何要记账

00:03:38.160 --> 00:03:41.040
凭什么你广播给我 我就要收着呢

00:03:41.080 --> 00:03:43.520
凭什么我要去花我自己的电脑资源

00:03:43.530 --> 00:03:45.830
记录一个跟我无关的这个账目呢 对不对

00:03:45.870 --> 00:03:48.100
为什么要记账 第二个问题

00:03:48.160 --> 00:03:54.050
第三个问题就是如何防伪 什么叫防伪呢

00:03:54.090 --> 00:03:58.880
比如说B广播的一条消息说A支付了10个比特币给他

00:03:58.920 --> 00:04:00.740
但实际上A并没有支付给他

00:04:00.780 --> 00:04:04.800
那这就是一个伪造的记录 我们怎么去防伪怎么去防止篡改

00:04:04.850 --> 00:04:07.320
之前的记录我把它改掉这个怎么办

00:04:07.590 --> 00:04:08.600
如何去防止篡改

00:04:08.880 --> 00:04:10.320
还有很多很多其他的问题

00:04:10.330 --> 00:04:12.000
比如说如何防止双重支付

00:04:12.250 --> 00:04:14.760
一个人同时发给两个人10个比特币

00:04:14.770 --> 00:04:16.459
但它实际上一共就只有10个比特币

00:04:16.670 --> 00:04:18.500
还有就是如何进行保密

00:04:18.510 --> 00:04:19.760
你这个信息都是公开的

00:04:19.769 --> 00:04:21.140
那别人不就知道你有多少钱了嘛

00:04:21.149 --> 00:04:22.850
怎么去保密等等一系列问题

00:04:22.890 --> 00:04:26.070
我们今天主要就研究前两个 以谁的账单为准

00:04:26.080 --> 00:04:27.470
还有我为什么要记账

00:04:27.510 --> 00:04:29.790
我们首先来说一下为什么要记账

00:04:29.840 --> 00:04:35.073
记账是因为记账有奖励 记账的奖励

00:04:38.450 --> 00:04:42.540
那么每一个比特币系统中的这个用户他都可以去记账

00:04:42.540 --> 00:04:45.660
如果他记了帐第一个他有手续费的收益

00:04:46.855 --> 00:04:48.050
手续费什么意思

00:04:48.330 --> 00:04:50.270
就是A付10个比特币给B的话

00:04:50.280 --> 00:04:52.330
A必须要多付出那么一点点

00:04:52.370 --> 00:04:54.610
这一点点就是给这个打包的这个人

00:04:54.620 --> 00:04:57.140
他记账的这个人他的一个手续费

00:04:57.240 --> 00:05:00.450
如果你要是用银行卡的话其实也有手续费 而且还其实挺高的

00:05:00.460 --> 00:05:02.190
那如果你用比特币手续费就低了

00:05:02.781 --> 00:05:04.211
这就是第一个他的收益

00:05:04.300 --> 00:05:07.670
第二个他的收益就是打包的那个人

00:05:07.710 --> 00:05:09.390
他有一个打包奖励

00:05:09.930 --> 00:05:13.490
打包的奖励 只能是一个人打包

00:05:13.620 --> 00:05:16.276
这一个人他会获得奖励 奖励是多少

00:05:16.350 --> 00:05:19.030
中本聪在2008年提出这个系统的时候

00:05:19.140 --> 00:05:20.530
他设计了这样一个方案

00:05:20.610 --> 00:05:23.030
就是每十分钟打一个包

00:05:23.040 --> 00:05:27.750
每十分钟打一个包 最开始这一个包会奖励打包者50个比特币

00:05:28.180 --> 00:05:32.060
过了四年之后每打一个包会奖励你25个比特币

00:05:32.260 --> 00:05:34.630
如果你要是再过四年就奖励12.5

00:05:34.640 --> 00:05:37.020
也就是每过四年之后它会减半

00:05:37.070 --> 00:05:38.830
咱们来算一算比特币一共有多少个

00:05:39.180 --> 00:05:41.550
首先每过十分钟你会打一个包

00:05:41.560 --> 00:05:43.510
这一个包有50个比特币的奖励

00:05:44.060 --> 00:05:46.970
一个小时六个10分钟 可以打包六次

00:05:47.510 --> 00:05:52.200
然后每天有24个小时 每年有365天

00:05:52.420 --> 00:05:55.320
前四年的时候都是这样 我再乘个四年

00:05:55.500 --> 00:05:58.340
但是第二个四年就不是这样 第二个四年会减半

00:05:58.790 --> 00:06:01.340
所以我再乘个第一个四年

00:06:01.380 --> 00:06:02.980
第二个四年会乘个1/2

00:06:03.030 --> 00:06:05.250
第三个四年会乘1/2的平方

00:06:05.300 --> 00:06:08.240
第四个四年(1/2)^3 这样一直加下去

00:06:08.250 --> 00:06:11.380
如果我们把都算出来 最后结果大概是2100万个

00:06:11.610 --> 00:06:15.640
也就是说这个比特币一共就只有2100万个

00:06:15.690 --> 00:06:18.770
它是通过打包奖励这种方式把它扩散出去的

00:06:19.590 --> 00:06:20.420
就是这样的一个问题

00:06:20.430 --> 00:06:23.670
那正因为有的这个手续费和打包奖励这两条

00:06:23.680 --> 00:06:25.210
所以大家都抢着去打包

00:06:25.250 --> 00:06:27.540
你抢着去打包那以谁为准

00:06:28.190 --> 00:06:30.685
下一个问题以谁为准 只能是一个人打包

00:06:30.800 --> 00:06:34.527
以谁为准 只能是一个人打包

00:06:35.100 --> 00:06:39.950
这个权利给谁 中本聪想到一个办法叫工作量证明

00:06:41.950 --> 00:06:43.420
这个工作量证明是什么意思

00:06:43.530 --> 00:06:47.210
就是说每一个参与的用户他都要去做一个很难的数学题

00:06:47.290 --> 00:06:49.300
这个很难的数学题你把它做出来了

00:06:49.350 --> 00:06:50.940
那你就可以有权利进行打包

00:06:50.950 --> 00:06:52.100
你如果要进行打包了

00:06:52.110 --> 00:06:53.870
你就会获得手续费以及打包奖励

00:06:54.390 --> 00:06:55.960
这个很难的数学题难到什么程度

00:06:56.050 --> 00:06:59.300
难到没有任何一个人能够直接通过脑子把它做出来

00:06:59.340 --> 00:07:01.950
我们必须一个一个数去尝试

00:07:02.000 --> 00:07:03.700
直到你把它尝试出来了

00:07:03.740 --> 00:07:05.020
那么你就获得这个奖励

00:07:05.030 --> 00:07:08.130
所以这个过程我们就称之为挖矿

00:07:09.830 --> 00:07:12.310
如果你把这个数学题做出来了

00:07:12.360 --> 00:07:14.250
你就获得了这个打包的奖励

00:07:14.260 --> 00:07:17.090
而这个打包的奖励就是几十个比特币

00:07:17.200 --> 00:07:19.990
你就称之为挖矿成功了 这就是挖矿的含义

00:07:20.040 --> 00:07:22.290
那么具体这个数学题到底是怎么回事

00:07:22.510 --> 00:07:23.590
咱们来往下继续说

00:07:23.630 --> 00:07:26.010
我们下面来讲一下挖矿的具体原理是什么

00:07:26.144 --> 00:07:27.563
挖矿的原理

00:07:28.445 --> 00:07:32.229
挖矿我们刚才说过它是做一个很难的数学题

00:07:32.320 --> 00:07:35.030
但是这个数学题并不是看你脑子聪明不聪明

00:07:35.070 --> 00:07:37.300
而是看你CPU的速度如何

00:07:37.430 --> 00:07:39.400
因为没有人能够通过脑子把它算出来

00:07:39.410 --> 00:07:42.313
大家的方法只能是一个一个试 具体的原理是什么

00:07:42.400 --> 00:07:43.480
首先我们回忆一下

00:07:43.490 --> 00:07:48.540
以前我们曾经讲过一种叫做哈希函数的东西

00:07:49.920 --> 00:07:54.310
这个哈希函数它的意思呢也可以叫数字摘要或者散列函数

00:07:54.450 --> 00:07:57.880
它的意思是说我们可以把一个字符串通过一定的运算

00:07:57.880 --> 00:07:59.520
转化成一个摘要的形式

00:07:59.560 --> 00:08:01.570
而且你正着算比较容易

00:08:01.580 --> 00:08:02.370
反着算很难

00:08:02.380 --> 00:08:06.590
比如说哈希算法里面有一个很著名的哈希算法叫SHA256

00:08:06.780 --> 00:08:11.180
SHA256这是美国国家安全局发明的一种算法

00:08:11.220 --> 00:08:14.290
如果我把一个字符串输入到这个SHA256函数里边

00:08:14.300 --> 00:08:16.130
比如这个字符串叫apple

00:08:16.314 --> 00:08:19.250
apple输出了多少呢

00:08:19.260 --> 00:08:21.710
输出的是一个二进制数

00:08:21.720 --> 00:08:23.150
这个二级数有256位

00:08:23.160 --> 00:08:27.030
比如说101011010... 没有什么规律

00:08:27.229 --> 00:08:29.917
一共有多少位呢 一共有256位

00:08:31.570 --> 00:08:32.899
所以就叫SHA256

00:08:32.980 --> 00:08:36.280
而且这个算法就是不管你前面输入的是什么

00:08:36.330 --> 00:08:38.990
那后面它结果都是256位的一个二进制数

00:08:39.049 --> 00:08:40.900
你把一个10个G的电影放进去

00:08:40.909 --> 00:08:42.750
它最后输出的还是256位的数

00:08:43.130 --> 00:08:45.640
而且如果你改一点点它这个数字都不一样

00:08:45.650 --> 00:08:48.240
比如我在apple这我加一个点 多了一个点

00:08:48.280 --> 00:08:50.870
最后这每一位的数字都有可能会发生变化

00:08:50.920 --> 00:08:52.120
这就是它的一个特点

00:08:52.120 --> 00:08:55.340
而且哈希算法的难度就在于它正向...

00:08:56.070 --> 00:09:01.100
有趣之处 它正向算比较容易 正向算比较容易

00:09:01.100 --> 00:09:07.260
但是它反向算非常的困难 这就是它算法的一个特点

00:09:07.590 --> 00:09:10.740
我们举个例子比如说有这么一个函数

00:09:10.780 --> 00:09:18.410
就是x^3+log2(x)+sin(x)=y 我是举个例子

00:09:18.450 --> 00:09:21.080
你给我一个x让我算出y来 其实这个并不难

00:09:21.120 --> 00:09:23.590
但是你给我一个y问我x是几 这就很困难

00:09:23.630 --> 00:09:27.360
哈希函数比这个还要复杂得多所以它反算基本上是不可能的

00:09:27.410 --> 00:09:28.400
我们只能怎么办

00:09:28.440 --> 00:09:29.580
我们只能一个一个去试

00:09:29.730 --> 00:09:31.420
假如你告诉我一个结果

00:09:31.430 --> 00:09:33.760
你问我什么结果是这个 那我就只能一个一个试

00:09:33.800 --> 00:09:35.280
一直把它试出来为止

00:09:35.410 --> 00:09:38.020
这个就是哈希算法的一个基本的问题

00:09:38.140 --> 00:09:42.100
那么这个挖矿其实就是基于这个SHA256的这么一个运算

00:09:42.240 --> 00:09:45.380
我们来说一下挖矿的具体的原理是什么

00:09:46.610 --> 00:09:50.710
刚才我们说到这个区块链其实是一大堆的交易信息

00:09:50.970 --> 00:09:52.130
一大堆的交易信息

00:09:52.430 --> 00:09:55.850
比如说这个区块链已经链接到了某一个位置

00:09:55.890 --> 00:09:57.780
从最开始第一个块开始链

00:09:57.830 --> 00:09:59.970
一直链 链到了某一个位置

00:09:59.970 --> 00:10:01.020
这是目前的情况

00:10:01.150 --> 00:10:03.260
这个块里并不只有交易信息

00:10:03.270 --> 00:10:07.430
它实际上是有一个块的头部 有一个块的头部

00:10:07.470 --> 00:10:09.460
还有它里边有一些内容

00:10:09.710 --> 00:10:11.570
这个内容其实就是信息

00:10:11.610 --> 00:10:14.206
就是我们交易的这个记录账单

00:10:14.660 --> 00:10:18.610
现在有很多的人说我现在都想进行打包

00:10:18.650 --> 00:10:20.706
为什么呢 因为打包有奖励还有手续费

00:10:21.070 --> 00:10:23.570
每一个人都有自己的一个账单

00:10:23.810 --> 00:10:27.310
这个账单是他收集了周围一大堆人造成的账单

00:10:27.360 --> 00:10:29.820
每一个人都拿着账单准备去网上接块

00:10:29.860 --> 00:10:32.460
但是在接块的时候他必须要算一个数学题

00:10:32.510 --> 00:10:35.640
什么数学题呢 首先它会有一个字符串

00:10:36.520 --> 00:10:38.650
它会有一个字符串

00:10:38.760 --> 00:10:40.570
这个字符串里边的内容非常多

00:10:40.720 --> 00:10:43.870
但是我们说一些主要的 这个字符串包含哪些内容呢

00:10:43.910 --> 00:10:47.750
首先包含目前的这个块 目前已有的这个块

00:10:47.760 --> 00:10:50.930
也就是前块 这个前块的头部

00:10:51.700 --> 00:10:53.030
这个前块的头部

00:10:53.260 --> 00:10:54.180
这是第一个部分

00:10:54.240 --> 00:11:00.060
第二个部分就是它现在已经有了这个账单的信息

00:11:00.297 --> 00:11:03.020
你已经有打包好的这个账单的信息

00:11:03.450 --> 00:11:07.020
还有比如说像时间之类的 时间戳之类的

00:11:07.540 --> 00:11:08.890
还有一大堆乱七八糟的

00:11:09.110 --> 00:11:12.150
然后还有一个很重要的就是有一个随机数

00:11:13.930 --> 00:11:15.300
这是你的一个字符串

00:11:15.340 --> 00:11:21.240
现在你对这个字符串做两次SHA256的运算

00:11:21.440 --> 00:11:24.120
它的哈希值等于什么呢

00:11:24.160 --> 00:11:26.380
等于SHA256

00:11:26.620 --> 00:11:31.280
然后SHA256 然后字符串

00:11:32.210 --> 00:11:35.110
你把这个字符串做两次这个哈希运算

00:11:35.470 --> 00:11:36.580
这个速度其实非常快

00:11:36.590 --> 00:11:38.320
你一下子能算出来这个数是几

00:11:38.410 --> 00:11:41.380
但是你算出来之后会发现它是一个256位的数

00:11:41.650 --> 00:11:44.425
这个256位的数我们要求什么呢

00:11:44.525 --> 00:11:49.628
要求它的前n位必须是0

00:11:50.890 --> 00:11:52.940
比如说你算出来的这么个数

00:11:52.950 --> 00:11:57.110
这个数结果是00000000...

00:11:57.150 --> 00:12:00.170
比如说有这个九个0 这有九个0

00:12:00.220 --> 00:12:02.264
然后后面是什么1011.....1

00:12:02.264 --> 00:12:04.740
一直到最后一共有256位

00:12:04.780 --> 00:12:05.840
你算出这么一个数来

00:12:05.850 --> 00:12:08.300
假如我的要求就是前九个位数是0

00:12:08.310 --> 00:12:09.160
那你就算对了

00:12:09.370 --> 00:12:10.020
你就算对了

00:12:10.070 --> 00:12:12.140
你算对了你就有资格去打包

00:12:12.190 --> 00:12:13.810
你就有资格打包的意思是说

00:12:13.850 --> 00:12:16.150
你要把你算出来的这个哈希值

00:12:16.150 --> 00:12:18.320
作为一个新块的头部

00:12:18.360 --> 00:12:22.067
然后你算出来这么一个数 对吧

00:12:22.180 --> 00:12:24.770
然后作为一个新块的头部打一个包

00:12:24.810 --> 00:12:27.140
打完了这个包之后再把你这个包干嘛

00:12:27.480 --> 00:12:28.840
接到后面去

00:12:28.840 --> 00:12:31.319
于是你就接出一个新块来

00:12:31.790 --> 00:12:33.920
接出个新块来你就获得了什么

00:12:34.090 --> 00:12:36.380
获得了你想要的奖励 就这样

00:12:36.480 --> 00:12:38.900
那么我们怎么能算出来前面这几位都是0呢

00:12:39.310 --> 00:12:42.000
就要改变一个内容 就是改变这个随机数

00:12:42.150 --> 00:12:44.140
其他的内容你是改不了的 对吧

00:12:44.150 --> 00:12:45.380
所以你就改变这个随机数

00:12:45.420 --> 00:12:47.030
随机数最开始从0开始

00:12:47.370 --> 00:12:47.940
从0开始

00:12:47.950 --> 00:12:49.760
0算一次 看看是不是满足条件

00:12:49.770 --> 00:12:51.130
不满足好算1

00:12:51.170 --> 00:12:52.375
1不行算2

00:12:52.375 --> 00:12:53.360
2不行算3

00:12:53.370 --> 00:12:54.220
它都是二进制的

00:12:54.310 --> 00:12:56.880
你就不停这么试 直到你把它试出来为止

00:12:56.920 --> 00:12:58.040
而且大家要注意

00:12:58.050 --> 00:13:01.380
每个人在计算的时候它的这个题目难度是不一样的

00:13:01.420 --> 00:13:02.052
为什么呢

00:13:02.140 --> 00:13:05.080
因为每一个人虽然前块的头部大家都一样

00:13:05.350 --> 00:13:08.550
但是你所打包的这个账单可能是不一样的 对吧

00:13:08.590 --> 00:13:10.700
你的时间 开始时间可能是不一样的

00:13:10.710 --> 00:13:12.520
还有你的个人信息也是不一样的

00:13:12.650 --> 00:13:15.000
所以造成了这个随机数大小不同

00:13:15.010 --> 00:13:17.030
有人运气好他第一个数就算出来了

00:13:17.120 --> 00:13:18.510
那直接就打包起来了 对吧

00:13:18.510 --> 00:13:19.300
有人运气不好

00:13:19.310 --> 00:13:20.210
他虽然计算能力强

00:13:20.220 --> 00:13:22.050
算得好长时间最后也算不出来

00:13:22.100 --> 00:13:23.820
不过平均来讲是这样的

00:13:23.830 --> 00:13:25.250
谁的计算能力更强

00:13:25.290 --> 00:13:27.600
谁就更有希望打包这个块

00:13:27.640 --> 00:13:30.000
谁就更有可能去挖到这个矿

00:13:30.068 --> 00:13:30.820
就是这样子的

00:13:30.907 --> 00:13:33.659
你说大家为什么拼命的去买这个矿机 对不对

00:13:33.838 --> 00:13:35.357
好 那我们继续往下说

00:13:35.357 --> 00:13:39.070
说这个 我们有一个难度的设置

00:13:39.110 --> 00:13:40.160
这个难度的设置

00:13:40.170 --> 00:13:41.420
也就是这个n位

00:13:41.690 --> 00:13:43.360
这个n是怎么确定的

00:13:43.710 --> 00:13:45.280
难度n的确定

00:13:45.563 --> 00:13:46.534
显而易见

00:13:46.620 --> 00:13:48.920
前面的这个0它个数越多

00:13:48.930 --> 00:13:50.120
这个问题它就越难

00:13:50.208 --> 00:13:51.584
为什么个数多就难

00:13:51.660 --> 00:13:54.680
咱们想象说在这个问题中你不可能反算

00:13:54.690 --> 00:13:56.380
只能是一个一个随机去试

00:13:57.145 --> 00:14:00.720
每一位上出现0的概率和出现1的概率各是50%

00:14:00.730 --> 00:14:02.060
所以第一个是0的话

00:14:02.110 --> 00:14:02.980
你概率是多少

00:14:03.030 --> 00:14:04.330
概率是1/2 对吧

00:14:04.370 --> 00:14:05.450
概率是1/2

00:14:05.490 --> 00:14:06.640
第二位是0的话

00:14:06.650 --> 00:14:07.070
概率多少

00:14:07.070 --> 00:14:08.000
概率也是1/2

00:14:08.040 --> 00:14:08.760
第三位是0

00:14:08.770 --> 00:14:09.940
概率也是1/2

00:14:10.010 --> 00:14:11.400
一直到最后一位是0

00:14:11.410 --> 00:14:12.480
概率也是1/2

00:14:12.520 --> 00:14:13.820
这样乘起来结果得多少

00:14:13.860 --> 00:14:16.490
得(1/2)^n 显而易见

00:14:16.540 --> 00:14:18.690
这个n越大 这个难度就越高

00:14:18.700 --> 00:14:20.739
n越小难度就越低 对吧

00:14:20.860 --> 00:14:22.490
那中本聪当时在设计的时候

00:14:22.500 --> 00:14:25.230
就是保证每十分钟

00:14:25.620 --> 00:14:28.750
每十分钟他需要出一个块

00:14:29.777 --> 00:14:30.530
需要出一个块

00:14:30.540 --> 00:14:32.080
然后打包几千条信息

00:14:32.440 --> 00:14:33.270
那怎么去保证

00:14:33.480 --> 00:14:35.040
就是调整这个n的难度

00:14:35.300 --> 00:14:36.430
调整这个n的数字

00:14:36.621 --> 00:14:37.580
我们举个例子

00:14:37.661 --> 00:14:38.590
比如说

00:14:38.760 --> 00:14:41.180
比如说世界上有1万台矿机

00:14:41.690 --> 00:14:43.560
1万台矿机

00:14:43.910 --> 00:14:48.820
这个1万台矿机每一台的计算能力是14个T每秒

00:14:48.900 --> 00:14:52.360
也就是每秒钟可以计算14T次哈希运算

00:14:52.430 --> 00:14:53.560
14T是多少

00:14:53.570 --> 00:14:54.910
1T是10的12次方

00:14:54.950 --> 00:14:59.490
所以这个数是1.4x10^13次每秒

00:15:01.384 --> 00:15:04.065
好 那么十分钟你到底能算多少次

00:15:04.301 --> 00:15:05.060
咱们算一下

00:15:05.180 --> 00:15:07.680
这个10分钟应该是600秒 对吧

00:15:07.720 --> 00:15:10.740
1.4x10^13

00:15:10.902 --> 00:15:13.090
这是每一个矿机一秒钟算的

00:15:13.150 --> 00:15:14.810
再乘以10的4次方

00:15:14.860 --> 00:15:16.420
这表示有1万台矿机

00:15:16.470 --> 00:15:19.950
然后你还得乘以10分钟大概是600秒 对吧

00:15:20.000 --> 00:15:24.010
这个数字大概是8x10^19

00:15:24.050 --> 00:15:27.420
也就是说十分钟大家可以进行这么多次运算

00:15:27.640 --> 00:15:28.370
这么多次运算

00:15:28.420 --> 00:15:29.440
那我们再想一下

00:15:29.480 --> 00:15:31.970
你如果概率是(1/2)^n

00:15:31.980 --> 00:15:33.350
你想出来这个块的话

00:15:33.360 --> 00:15:35.810
你需要计算的次数就是2^n吧

00:15:35.820 --> 00:15:37.220
你概率1/64的话

00:15:37.270 --> 00:15:39.310
你出的这个块平均你要算64次

00:15:39.380 --> 00:15:41.690
同样道理你算了这么多次

00:15:41.950 --> 00:15:42.450
对不对

00:15:42.480 --> 00:15:45.397
那么它大概相当于是2的多少次幂

00:15:45.560 --> 00:15:46.880
我们可以通过计算发现

00:15:46.930 --> 00:15:50.150
如果这个n等于66的话

00:15:50.780 --> 00:15:52.840
这个时候你的出现概率

00:15:52.850 --> 00:15:55.680
能够算出概率是(1/2)^66

00:15:55.830 --> 00:15:58.857
然后你平均需要算的次数

00:15:58.950 --> 00:16:01.810
平均的次数就是2^66

00:16:01.850 --> 00:16:04.640
大概也是8x10^19

00:16:04.780 --> 00:16:08.930
所以在这种情况下矿机就会把难度设置成n等于66

00:16:08.980 --> 00:16:11.970
第一个能够算出来前66位全都是0的人

00:16:12.095 --> 00:16:13.263
就成功打包这个块

00:16:13.263 --> 00:16:14.470
就成功地挖到了矿

00:16:14.560 --> 00:16:16.470
你没有办法让自己运气变得更好

00:16:16.480 --> 00:16:18.290
你能够做得就是买更多的矿机

00:16:18.300 --> 00:16:19.810
然后拼命的去挖矿

00:16:19.820 --> 00:16:21.730
这样你就有可能会得到这个比特币

00:16:21.780 --> 00:16:23.419
大概就是这样一个原理 是吧

00:16:23.490 --> 00:16:26.910
好 我们这次解释的到底区块链这个块到底是怎么形成

00:16:26.920 --> 00:16:28.672
但实际上还有很多问题没有解决

00:16:28.830 --> 00:16:32.540
比如说我们如何去防止这个双重支付的问题就没有解决

00:16:32.580 --> 00:16:35.130
我们还没有解决说我们怎么防止伪造的问题

00:16:35.280 --> 00:16:38.070
那这些问题我们会在下一回再给大家做介绍

00:16:38.147 --> 00:16:39.260
大家如果喜欢我的视频

00:16:39.260 --> 00:16:41.920
可以在西瓜视频和YouTube帐号李永乐老师里关注我

